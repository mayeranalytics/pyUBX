# Lang C++

It is easiest to look at an example. 

```cpp
// File lang/cpp/src/MON.h
// Auto-generated by generateCpp.py v0.1 on 2017-10-30T16:56:07.208773

#include <stdint.h>
#include "UBX.h"

struct MON
{
    struct VER;
};

struct MON::VER
{
    char swVersion[30];
    char hwVersion[10];
    struct Repeated {
        char extension[30];
    };
    typedef _iterator<MON::VER::Repeated> iterator;
    static _iterator<Repeated> iter(char*data, size_t size) {
        return _iterator<Repeated>(data+sizeof(MON::VER), size-sizeof(MON::VER));
    }
};
```

It is easy enough to automatically create the appropriate `struct`s since the UBX types map directly onto C types. The only complication comes from the repeated blocks that give rise to variable length messages. We don't want to use `vector` or other STL containers because they are not  suited for microcontrollers, usually. Instead, iterators are used. They do not have the STL compatible`begin()` and `end` functions.

The data structure corresponding to each UBX message is just the sequence of non-repeated fields packed into a struct. The repeated fields are accessed by an iterator.

The iterator is instantiated with a pointer to the data and the length of the data.

```c++
MON::VER::iterator i=MON::VER:iter(data, size);
```

The data needs to be allocated in advance. No range checking is performed!

Data is accesses with the `*` and `->` operators

```c++
char* ext = iter->extension;
```



## Testing
### Google `gtest`

Add submodule:

```bash
git submodule add https://github.com/google/googletest.git
```

Build googletest
```bash
cd googletest
cmake .
make -j
```

